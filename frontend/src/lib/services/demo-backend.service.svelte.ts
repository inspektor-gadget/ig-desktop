// Copyright 2025 The Inspektor Gadget authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import type {
	Environment,
	SessionItem,
	SessionWithRuns,
	GadgetRun,
	RecordedEvent,
	GadgetInfo,
	GadgetRunRequest
} from '$lib/types';
import { resolve } from '$app/paths';
import { setEnvPref, getEnvPref } from '$lib/utils/env-preferences';

/**
 * Demo session data structure - loaded from JSON files
 */
export interface DemoSession {
	session: SessionWithRuns;
	events: Record<string, RecordedEvent[]>; // runId -> events
}

/**
 * Unified demo run data - used for both recents and instances.
 * Generated by session-export --run <runId>
 */
export interface DemoRunData {
	id: string;
	name: string;
	image: string;
	params: Record<string, string>;
	gadgetInfo: GadgetInfo;
	events: RecordedEvent[];
}

/**
 * Demo mode configuration - loaded from /demo/config.json
 */
export interface DemoConfig {
	environment: Environment;
	/** Paths to session JSON files relative to /demo/sessions/ */
	sessions: string[];
	/** Paths to recent gadget JSON files relative to /demo/recents/ */
	recents: string[];
	/** Paths to headless instance JSON files relative to /demo/instances/ */
	instances: string[];
}

type MessageHandler = (message: string) => void;

/**
 * Demo backend service that simulates the backend using pre-recorded session data.
 * Implements a similar interface to the real backend but serves static data.
 */
export class DemoBackendService {
	private config: DemoConfig | null = null;
	private sessions: Map<string, DemoSession> = new Map();
	private recents: Map<string, DemoRunData> = new Map(); // image -> data
	private instances: Map<string, DemoRunData> = new Map(); // id -> data
	private messageHandler: MessageHandler | null = null;

	/**
	 * Set the message handler for sending messages back to the frontend.
	 */
	setMessageHandler(handler: MessageHandler): void {
		this.messageHandler = handler;
	}

	/**
	 * Initialize demo mode - load config and session metadata.
	 */
	async initialize(): Promise<void> {
		try {
			// Load demo config
			const configResponse = await fetch(resolve(`/demo/config.json`));
			if (!configResponse.ok) {
				console.error('Failed to load demo config:', configResponse.status);
				return;
			}
			this.config = await configResponse.json();

			// Send environment to frontend (type 100 = TypeEnvironmentCreate)
			this.sendMessage({
				type: 100,
				data: this.config.environment
			});

			// Load all session files
			for (const sessionPath of this.config.sessions) {
				try {
					const response = await fetch(resolve(`/demo/sessions/${sessionPath}`));
					if (!response.ok) {
						console.error(`Failed to load session ${sessionPath}:`, response.status);
						continue;
					}
					const sessionData: DemoSession = await response.json();
					this.sessions.set(sessionData.session.id, sessionData);
				} catch (err) {
					console.error(`Error loading session ${sessionPath}:`, err);
				}
			}

			// Load all recent gadget files
			for (const recentPath of this.config.recents || []) {
				try {
					const response = await fetch(resolve(`/demo/recents/${recentPath}`));
					if (!response.ok) {
						console.error(`Failed to load recent ${recentPath}:`, response.status);
						continue;
					}
					const recentData: DemoRunData = await response.json();
					this.recents.set(recentData.image, recentData);
				} catch (err) {
					console.error(`Error loading recent ${recentPath}:`, err);
				}
			}

			// Load all instance files
			for (const instancePath of this.config.instances || []) {
				try {
					const response = await fetch(resolve(`/demo/instances/${instancePath}`));
					if (!response.ok) {
						console.error(`Failed to load instance ${instancePath}:`, response.status);
						continue;
					}
					const instanceData: DemoRunData = await response.json();
					this.instances.set(instanceData.id, instanceData);
				} catch (err) {
					console.error(`Error loading instance ${instancePath}:`, err);
				}
			}

			// Seed gadget history from recents if not already populated
			this.seedGadgetHistory();

			console.log(
				`Demo backend initialized with ${this.sessions.size} sessions, ${this.recents.size} recents, ${this.instances.size} instances`
			);
		} catch (err) {
			console.error('Error initializing demo backend:', err);
		}
	}

	/**
	 * Seed the gadget history localStorage with demo recents data.
	 */
	private seedGadgetHistory(): void {
		if (!this.config?.environment.id) return;

		const envId = this.config.environment.id;
		const historyEntries: GadgetRunRequest[] = [];
		const now = Date.now();

		for (const [, recentData] of this.recents) {
			historyEntries.push({
				image: recentData.image,
				params: recentData.params || {},
				timestamp: now - historyEntries.length * 60000 // Stagger timestamps
			});
		}

		if (historyEntries.length > 0) {
			setEnvPref(envId, 'gadget-history', historyEntries);
			console.log(`Demo: seeded ${historyEntries.length} entries to gadget history`);
		}
	}

	/**
	 * Handle incoming commands from the frontend.
	 */
	handleCommand(message: string): void {
		try {
			const msg = JSON.parse(message);

			switch (msg.cmd) {
				case 'helo':
					// Initial handshake - environment already sent in initialize()
					// Send version info
					if (msg.reqID) {
						this.sendResponse(msg.reqID, true, { version: 'demo' });
					}
					break;

				case 'getVersion':
					this.sendResponse(msg.reqID, true, { version: 'demo' });
					break;

				case 'listSessions':
					this.handleListSessions(msg);
					break;

				case 'getSession':
					this.handleGetSession(msg);
					break;

				case 'getRun':
					this.handleGetRun(msg);
					break;

				case 'getRunEvents':
					this.handleGetRunEvents(msg);
					break;

				case 'replaySession':
					this.handleReplaySession(msg);
					break;

				case 'runGadget':
					this.handleRunGadget(msg);
					break;

				case 'listInstances':
					this.handleListInstances(msg);
					break;

				case 'attachInstance':
					this.handleAttachInstance(msg);
					break;

				case 'detachInstance':
				case 'stopInstance':
					// Allow detach/stop to succeed silently in demo mode
					this.sendResponse(msg.reqID, true, {});
					break;

				default:
					// Return error for unsupported commands
					this.sendResponse(msg.reqID, false, null, 'Operation not supported in demo mode');
			}
		} catch (err) {
			console.error('Error handling demo command:', err);
		}
	}

	private handleListSessions(msg: { reqID: string; data?: { environmentId: string } }): void {
		const sessions: SessionItem[] = [];
		for (const [, data] of this.sessions) {
			sessions.push({
				id: data.session.id,
				name: data.session.name,
				environmentId: data.session.environmentId,
				createdAt: data.session.createdAt,
				updatedAt: data.session.updatedAt,
				runCount: data.session.runCount
			});
		}
		this.sendResponse(msg.reqID, true, sessions);
	}

	private handleGetSession(msg: { reqID: string; data?: { sessionId: string } }): void {
		const sessionId = msg.data?.sessionId;
		if (!sessionId) {
			this.sendResponse(msg.reqID, false, null, 'Session ID required');
			return;
		}

		const session = this.sessions.get(sessionId);
		if (!session) {
			this.sendResponse(msg.reqID, false, null, 'Session not found');
			return;
		}
		this.sendResponse(msg.reqID, true, session.session);
	}

	private handleGetRun(msg: { reqID: string; data?: { sessionId: string; runId: string } }): void {
		const { sessionId, runId } = msg.data || {};
		if (!sessionId || !runId) {
			this.sendResponse(msg.reqID, false, null, 'Session ID and Run ID required');
			return;
		}

		const session = this.sessions.get(sessionId);
		if (!session) {
			this.sendResponse(msg.reqID, false, null, 'Session not found');
			return;
		}

		const run = session.session.runs.find((r) => r.id === runId);
		if (!run) {
			this.sendResponse(msg.reqID, false, null, 'Run not found');
			return;
		}
		this.sendResponse(msg.reqID, true, run);
	}

	private handleGetRunEvents(msg: {
		reqID: string;
		data?: { sessionId: string; runId: string };
	}): void {
		const { sessionId, runId } = msg.data || {};
		if (!sessionId || !runId) {
			this.sendResponse(msg.reqID, false, null, 'Session ID and Run ID required');
			return;
		}

		const session = this.sessions.get(sessionId);
		if (!session) {
			this.sendResponse(msg.reqID, false, null, 'Session not found');
			return;
		}

		const events = session.events[runId] || [];
		this.sendResponse(msg.reqID, true, events);
	}

	private async handleReplaySession(msg: {
		reqID: string;
		data?: { sessionId: string; runId: string; mode?: 'instant' | 'realtime' };
	}): Promise<void> {
		const { sessionId, runId, mode = 'instant' } = msg.data || {};
		if (!sessionId || !runId) {
			this.sendResponse(msg.reqID, false, null, 'Session ID and Run ID required');
			return;
		}

		const session = this.sessions.get(sessionId);
		if (!session) {
			this.sendResponse(msg.reqID, false, null, 'Session not found');
			return;
		}

		const run = session.session.runs.find((r) => r.id === runId);
		if (!run) {
			this.sendResponse(msg.reqID, false, null, 'Run not found');
			return;
		}

		const events = session.events[runId] || [];

		// Generate a unique instance ID for this replay
		const instanceID = `replay-${Date.now()}`;

		// Send gadget info (type 2)
		this.sendMessage({
			type: 2,
			instanceID,
			environmentID: this.config?.environment.id,
			data: run.gadgetInfo,
			instanceName: run.gadgetImage
		});

		// Return success with instance ID
		this.sendResponse(msg.reqID, true, { id: instanceID });

		// Replay events
		if (mode === 'realtime') {
			await this.replayEventsRealtime(instanceID, events);
		} else {
			this.replayEventsInstant(instanceID, events);
		}

		// Send quit (type 5)
		this.sendMessage({
			type: 5,
			instanceID
		});
	}

	/**
	 * Handle runGadget command - replay from recents data if available
	 */
	private async handleRunGadget(msg: {
		reqID: string;
		data?: { image: string; environmentID: string; params?: Record<string, string> };
	}): Promise<void> {
		const { image } = msg.data || {};
		if (!image) {
			this.sendResponse(msg.reqID, false, null, 'Gadget image required');
			return;
		}

		// Find matching recent by image
		const recentData = this.recents.get(image);
		if (!recentData) {
			this.sendResponse(msg.reqID, false, null, 'Gadget not available in demo mode');
			return;
		}

		// Generate a unique instance ID for this run
		const instanceID = `demo-run-${Date.now()}`;

		// Send gadget info (type 2)
		this.sendMessage({
			type: 2,
			instanceID,
			environmentID: this.config?.environment.id,
			data: recentData.gadgetInfo,
			instanceName: recentData.image
		});

		// Return success with instance ID
		this.sendResponse(msg.reqID, true, { id: instanceID });

		// Replay events in realtime for a better demo experience
		await this.replayEventsRealtime(instanceID, recentData.events);

		// Send quit (type 5)
		this.sendMessage({
			type: 5,
			instanceID
		});
	}

	/**
	 * Handle listInstances command - return loaded demo instances
	 */
	private handleListInstances(msg: { reqID: string; data?: { environmentID: string } }): void {
		const gadgetInstances = Array.from(this.instances.values()).map((inst) => ({
			id: inst.id,
			name: inst.name,
			tags: '',
			gadgetConfig: {
				imageName: inst.image
			}
		}));
		this.sendResponse(msg.reqID, true, { gadgetInstances });
	}

	/**
	 * Handle attachInstance command - replay from instance data
	 */
	private async handleAttachInstance(msg: {
		reqID: string;
		data?: { environmentID: string; image: string; instanceName: string };
	}): Promise<void> {
		const { image: instanceId } = msg.data || {};
		if (!instanceId) {
			this.sendResponse(msg.reqID, false, null, 'Instance ID required');
			return;
		}

		// Find instance by ID
		const instanceData = this.instances.get(instanceId);
		if (!instanceData) {
			this.sendResponse(msg.reqID, false, null, 'Instance not found');
			return;
		}

		// Generate a unique instance ID for this attach session
		const attachInstanceID = `demo-attach-${Date.now()}`;

		// Send gadget info (type 2) with attached flag
		this.sendMessage({
			type: 2,
			instanceID: attachInstanceID,
			environmentID: this.config?.environment.id,
			data: instanceData.gadgetInfo,
			instanceName: instanceData.name,
			attached: true
		});

		// Return success with instance ID
		this.sendResponse(msg.reqID, true, { id: attachInstanceID });

		// Replay events in realtime for a better demo experience
		await this.replayEventsRealtime(attachInstanceID, instanceData.events);

		// Send quit (type 5)
		this.sendMessage({
			type: 5,
			instanceID: attachInstanceID
		});
	}

	/**
	 * Replay events instantly (all at once)
	 */
	private replayEventsInstant(instanceID: string, events: RecordedEvent[]): void {
		for (const event of events) {
			this.sendMessage({
				type: event.type,
				instanceID,
				datasourceID: event.datasourceId,
				data: event.data
			});
		}
	}

	/**
	 * Replay events with realistic timing based on recorded timestamps.
	 * Uses actual time deltas between events, capped at 2 seconds to avoid long pauses.
	 */
	private async replayEventsRealtime(instanceID: string, events: RecordedEvent[]): Promise<void> {
		if (events.length === 0) return;

		let lastTimestamp = events[0].timestamp;

		for (const event of events) {
			// Use actual timing from recording, cap at 2 seconds to avoid overly long pauses
			const delay = Math.min(event.timestamp - lastTimestamp, 2000);
			if (delay > 0) {
				await new Promise((resolve) => setTimeout(resolve, delay));
			}
			lastTimestamp = event.timestamp;

			// Send event based on type
			this.sendMessage({
				type: event.type,
				instanceID,
				datasourceID: event.datasourceId,
				data: event.data
			});
		}
	}

	private sendResponse(reqID: string, success: boolean, data: unknown, error?: string): void {
		this.sendMessage({
			type: 1, // TypeCommandResponse
			reqID,
			success,
			data,
			error
		});
	}

	private sendMessage(msg: unknown): void {
		if (this.messageHandler) {
			this.messageHandler(JSON.stringify(msg));
		}
	}
}

/**
 * Singleton instance of DemoBackendService.
 */
export const demoBackend = new DemoBackendService();
